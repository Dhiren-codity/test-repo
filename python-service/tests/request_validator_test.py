import pytest
from unittest.mock import patch
from datetime import datetime as real_datetime

from src.request_validator import (
    ValidationError,
    log_validation_errors,
    get_validation_errors,
    clear_validation_errors,
)


@pytest.fixture
def fixed_datetime():
    """Provide a fixed datetime object for consistent timestamp testing."""
    return real_datetime(2023, 1, 2, 3, 4, 5, 123456)


@pytest.fixture
def mock_datetime_now(monkeypatch, fixed_datetime):
    """Monkeypatch src.request_validator.datetime.now to return a fixed datetime."""
    class FixedDateTime:
        @classmethod
        def now(cls):
            return fixed_datetime

    monkeypatch.setattr("src.request_validator.datetime", FixedDateTime)


@pytest.fixture
def validation_error_instance(mock_datetime_now):
    """Create a ValidationError instance with a deterministic timestamp."""
    return ValidationError(field="test_field", reason="test_reason")


def test_validationerror_init_sets_fields_and_timestamp(mock_datetime_now, fixed_datetime):
    """ValidationError __init__ sets field, reason, and ISO timestamp."""
    err = ValidationError(field="content", reason="missing")
    assert err.field == "content"
    assert err.reason == "missing"
    assert err.timestamp == fixed_datetime.isoformat()


def test_validationerror_to_dict_serializes_all_fields(validation_error_instance, fixed_datetime):
    """ValidationError.to_dict returns the expected dict shape with deterministic timestamp."""
    d = validation_error_instance.to_dict()
    assert d == {
        "field": "test_field",
        "reason": "test_reason",
        "timestamp": fixed_datetime.isoformat(),
    }


def test_validationerror_init_accepts_non_string_values(mock_datetime_now, fixed_datetime):
    """ValidationError accepts non-string field and reason and preserves them in to_dict."""
    field_value = 123
    reason_value = {"code": "E001", "msg": "error"}
    err = ValidationError(field=field_value, reason=reason_value)

    assert err.field == field_value
    assert err.reason == reason_value

    d = err.to_dict()
    assert d["field"] == field_value
    assert d["reason"] == reason_value
    assert d["timestamp"] == fixed_datetime.isoformat()


def test_validationerror_init_raises_when_datetime_now_fails(monkeypatch):
    """ValidationError __init__ propagates exceptions if datetime.now fails."""
    class BrokenDateTime:
        @classmethod
        def now(cls):
            raise RuntimeError("clock failure")

    monkeypatch.setattr("src.request_validator.datetime", BrokenDateTime)

    with pytest.raises(RuntimeError):
        ValidationError(field="field", reason="reason")


def test_validationerror_to_dict_used_by_log_validation_errors(monkeypatch):
    """log_validation_errors calls ValidationError.to_dict and appends its result."""
    clear_validation_errors()
    err = ValidationError(field="x", reason="y")

    sentinel = {"field": "X", "reason": "Y", "timestamp": "T"}
    with patch.object(err, "to_dict", return_value=sentinel) as mock_to_dict:
        log_validation_errors([err])

    mock_to_dict.assert_called_once_with()
    stored = get_validation_errors()
    assert stored == [sentinel]


def test_validationerror_timestamp_is_isoformat_string():
    """Timestamp generated by ValidationError is an ISO formatted string."""
    err = ValidationError(field="any", reason="any")
    ts = err.timestamp
    # Basic ISO-8601 sanity checks
    assert isinstance(ts, str)
    assert "T" in ts
    assert len(ts) >= 19  # YYYY-MM-DDTHH:MM:SS minimal length without microseconds